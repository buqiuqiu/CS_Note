## 单线程服务器的常用编程模型
在高性能的网络程序中，使用得最广泛得恐怕要数“non-blocking IO + IO multiplexing” 这种模型，即 [Reactor 模式](annotation/Reactor.md)

lighttpd，单线程服务器。（Nginx与之类似，每个工作进程有一个event loop）
libevent，libev
ACE，Poco C++ libraries
Java NIO，包括Apache Mina和Netty
POE（Perl）
Twisted（Python）

相反，Boost.Asio和Windows I/O Completion Ports实现了Proactor模式，应用面似乎要窄一些。此外，ACE也实现了Proactor模式。

在“non-blocking IO＋IO multiplexing”这种模型中，程序的基本结构是一个事件循环（event loop），以事件驱和事件回调的方式实现业务逻辑：

Reactor模型的优点:
编程不难，效率也不错
不仅可以用于读写socket，连接的建立（connect/accept）甚至DNS解析（gethostbyname是阻塞的，对陌生域名解析的耗时可长达数秒）都可以用非阻塞方式进行，以提高并发度和吞吐量（throughput），对于IO密集的应用是个不错的选择
lighttpd就是这样，它内部的fdevent结构十分精妙，值得学习。

基于事件驱动的编程模型也有其本质的缺点：
它要求事件回调函数必须是非阻塞的
对于涉及网络IO的请求响应式协议，它容易割裂业务逻辑，使其散布于多个回调函数之中，相对不容易理解和维护

但现代的语言有一些应对方法（例如coroutine）

## 多线程服务器常用编程模型
1．每个请求创建一个线程，使用阻塞式IO操作。在Java 1.4引入 NIO之前，这是Java网络编程的推荐做法。可惜伸缩性不佳。
2．使用线程池，同样使用阻塞式IO操作。与第1种相比，这是提高性能的措施
3．使用non-blocking IO＋IO multiplexing。即Java NIO的方式
4．Leader/Follower等高级模式

在默认情况下一般使用第3种，即non-blocking IO＋one loop per thread模式来编写多线程C++网络服务程序。
### one(event) loop per thread 
### thread pool
## 推荐模式
总结起来，推荐的C++多线程服务端编程模式为：one (event) loop per thread+thread pool：
> event loop（也叫IO loop）用作IO multiplexing，配合non-blocking IO和定时器
> thread pool用来做计算，具体可以是任务队列或生产者消费者队列
以这种方式写服务器程序，需要一个优质的基于Reactor模式的网络库来支撑，muduo正是这样的网络库：

程序里具体用几个loop、线程池的大小等参数需要根据应用来设定，基本的原则是“阻抗匹配”，使得CPU和IO都能高效地运作。
此外，程序里或许还有个别执行特殊任务的线程，比如logging，这对应用程序来说基本是不可见的，但是在分配资源（CPU和IO）的时候要算进去，以免高估了系统的容量。

## 进程间通信只用 TCP 
Linux下进程间通信（IPC）的方式数不胜数，光《UNIX网络编程》列出的就有：匿名管道（pipe）、具名管道（FIFO）、POSIX消息队列、共享内存、信号（signals）等等，更不必说Sockets了。
同步原语 （synchronization primitives）也很多，如互斥器（mutex）、条件变量 （condition variable）、读写锁（reader-writer lock）、文件锁（record locking）、信号量（semaphore）等等。

进程间通信我首选Sockets（主要指TCP，我没有用过UDP，也不考虑Unix domain协议）。
1. 跨主机，具有伸缩性。
   其最大的好处在于：可以跨主机，具有伸缩性（scalability）
   反正都是多进程了，如果一台机器的处理能力不够，很自然地就能用多台机器来处理。把进程分散到同一局域网的多台机器上，程序改改host:port配置就能继续用。相反，前面列出的其他IPC都不能跨机器（比如共享内存效率最高，但受网络带宽及延迟限制，无论如何也不能高效地共享两台物理机器的内存）， 这就限制了scalability
2. 双向
   在编程上，TCP sockets和pipe都是操作文件描述符，用来收发字节流，都可以read/write/fcntl/select/poll等
   TCP VS pipe：
      TCP是双向的， Linux的pipe是单向的，进程间双向通信还得开两个文件描述符，不方便（可以用socketpair替代）
      而且进程要有父子关系才能用pipe，这些都限制了pipe的使用
   在收发字节流这一通信模型下，没有比Sockets/TCP更自然的IPC了
   当然， pipe也有一个经典应用场景，那就是：
      写Reactor/event loop时用来异步唤醒select（或等价的poll/epoll_wait）调用（在Linux下，可以用eventfd代替，效率更高）
      Sun HotSpot JVM在Linux就是这么做的
3. port独占，自动回收
   TCP port由一个进程独占，且操作系统会自动回收（listening port和已建立连接的TCP socket都是文件描述符，在进程结束时操作系统会关闭所有文件描述符）
   这说明，即使程序意外退出，也不会给系统留下垃圾，程序重启之后能比较容易地恢复，而不需要重启操作系统（用跨进程的mutex就有这个风险）
   还有一个好处，既然port是独占的，那么可以防止程序重复启动，后面那个进程抢不到port，自然就没法初始化 了，避免造成意料之外的结果
4. 关闭感知
   两个进程通过TCP通信，如果一个崩溃了，操作系统会关闭连接， 另一个进程几乎立刻就能感知，可以快速failover
   当然应用层的心跳也是必不可少的（可参阅后面的“分布式系统工程实践之分布式系统中心跳协议的设计”文章）
5. 可记录，可重现，跨语言
   与其他IPC相比，TCP协议的一个天生的好处是“可记录、可重 现”
   tcpdump和Wireshark是解决两个进程间协议和状态争端的好帮手， 也是性能（吞吐量、延迟）分析利器。我们可以借此编写分布式程序 的自动化回归测试。也可以用tcpcopy（http://code.google.com/p/tcpcopy）之类的工具进行压力测试
   TCP还能跨语言，服务端和客户端不必使用同一种语言。试想如果用共享内存作为IPC，C++程序如何与Java通信，难道用JNI吗？
6. 可再生
   另外，如果网络库带“连接重试”功能的话，我们可以不要求系统里的进程以特定的顺序启动，任何一个进程都能单独重启
   换句话说， TCP连接是可再生的，连接的任何一方都可以退出再启动，重建连接之后就能继续工作，这对开发牢靠的分布式系统意义重大。
   
使用TCP这种字节流（byte stream）方式通信，会有marshal/unmarshal的开销，这要求我们选用合适的消息格式，准确地说是wire format，目前我推荐Google Protocol Buffers。

![](image/2020-08-26-20-41-41.png)
### 分布式系统中使用 TCP 长连接通信

分布式系统的软件设计和功能划分一般应该以“进程”为单位。从宏观上看，一个分布式系统是由运行在多台机器上的多个进程组成的，进程之间采用TCP长连接通信
我提倡用多线程，并不是说把整个系统放到一个进程里实现，而是指功能划分之后，在实现每一类服务进程时，在必要时可以借助多线程来提高性能。对于整个分布式系统，要做到能scale out，即享受增加机器带来的好处。


TCP长连接的两个优点
一是容易定位分布式系统中的服务之间的依赖关系：
   只要在机器上运行netstat -tpna | grep :port就能立刻列出用到某服务的客户端地址（Foreign列），然后在客户端的机器上用 netstat或lsof命令找出是哪个进程发起的连接
   这样在迁移服务的时候能有效地防止出现outage
   TCP短连接和UDP则不具备这一特性
二是通过接收和发送队列的长度也较容易定位网络或程序故障：
   在正常运行的时候，netstat打印的Recv-Q和Send-Q都应该接近0，或者在0附近摆动
   如果Recv-Q保持不变或持续增加，则通常意味着服务进程的处理速度变慢，可能发生了死锁或阻塞
   如果Send-Q保持不变或持续增加，有可能是对方服务器太忙、来不及处理，也有可能是网络中间某个路由器或交换机故障造成丢包，甚至对方服务器掉线，这些因素都可能表现为数据发送不出去
   通过持续监控Recv-Q和Send-Q就能及早预警性能或可用性故障
   以下是服务端线程阻塞造成Recv-Q和客户端Send-Q激增的例子
   ![](image/2020-08-26-20-43-45.png)

## 多线程服务器的适用场合

“服务器开发”包罗万象，用一句话形容是：跑在多核机器上的Linux用户态的没有用户界面的长期运行（“长期运行”的意思不是指程序7 x 24不重启，而是程序不会因为无事可做而退出，它会等着下一个请求的到来。例如wget是不长期运行，httpd是长期运行的）的网络应用程序，通常是分布式系统的组成部件