## 多线程服务器的适用场合”的例释与答疑
### 一、Linux能同时启动多少个线程？
1. 对于32-bit Linux：
一个进程的地址空间是4GiB，其中用户态能访问 3GiB左右，而一个线程的默认栈大小是10MB，心算可知，一个进程大约最多能同时启动300个线程
如果不改线程的调用栈大小的话，300左右是上限，因为程序的其他部分（数据段、代码段、堆、动态库等等）同样要占用内存（地址空间）
2. 对于64-bit系统：
线程数目可大大增加，具体数字我没有测试过， 因为我在实际项目中一台机器上最多只用到过几十个用户线程，其中大部分还是空闲的
下面的第2问关于线程数目的讨论以32-bit Linux为例.

### 二、多线程能提高并发度吗？
如果指的是“并发连接数”，则不能。
假如单纯采用thread per connection的模型，那么并发连接数最多300，这远远低于基于事件的单线程程序所能轻松达到的并发连接数（几千乃至 g上万，甚至几万）。所谓“基于事件”，指的是用IO multiplexing event loop的编程模型，又称Reactor模式，在前文中已有介绍。
那么采用前文中推荐的one loop per thread呢？至少不逊于单线程程序。实际上单个event loop处理1万个并发长连接并不罕见，一个multi-loop的多线程程序应该能轻松支持5万并发链接。
小结：
**thread per connection不适合高并发场合，其scalability不佳**
**one loop per thread的并发度足够大，且与CPU数目成正比**

### 三、多线程能提高吞吐量吗？
对于计算密集型服务不能。但是可以降低延迟，优化响应时间。
为了在并发请求数很高时也能保持稳定的吞吐量，我们可以用线程池：
线程池的大小应该满足“阻抗匹配原则”，见问题7
线程池也不是万能的：
如果响应一次请求需要做比较多的计算（比如计算的时间占整个response time的1/5强），那么用线程池是合理的， 能简化编程。
如果在一次请求响应中，主要时间是在等待IO，那么为了进一步提高吞吐量，往往要用其他编程模型，比如Proactor，见问题8。

### 四、多线程能降低响应时间吗？
如果设计合理，充分利用多核资源的话，可以。在突发（burst）请求时效果尤为明显。

### 五、多线程程序如何让IO和“计算”相互重叠，降低latency？
基本思路是，把IO操作（通常是写操作）通过BlockingQueue交给别的线程去做，自己不必等待。

如：日志logging写操作 memcached 详见书籍。

### 六、为什么第三方库往往要自己的线程？

event loop模型没有标准实现。
对于Java，这个问题还好办一些，因为thread pool在Java里有标准实现，叫ExecutorService。如果第三方库支持线程池，那么它可以和主程序共享一个ExecutorService，而不是自己创建一堆线程。（比如在初始化时传入主程序的obj）
对于C++，情况麻烦得多，Reactor和thread pool都没有标准库。

libmemcached只支持同步操作。万幸的是，memcached的协议非常简单，大不了可以自己写一个基 于Reactor的客户端，但是数据库客户端就没那么幸运了。
MySQL的官方C API不支持异步操作。
相比之下，PostgreSQL的C客户端libpq的设计要好得多，我们可以用PQsendQuery()来发起一次查询，然后用标准的select/poll/epoll来等待PQsocket。如果有数据可读，那么用PQconsumeInput处理之，并用 PQisBusy判断查询结果是否已就绪。最后用PQgetResult来获取结果。借 助这套异步API，我们可以很容易地为libpq写一套wrapper，使之融入程 序所用的event loop模型中

### 七、什么是线程池大小的阻抗匹配原则？
如果池中线程在执行任务时，密集计算所占的时间比重为P（0＜ P≤1），而系统一共有C个CPU，为了让这C个CPU跑满而又不过载，线 程池大小的经验公式T＝C/P。T是个hint，考虑到P值的估计不是很准 确，T的最佳值可以上下浮动50％.这个经验公式的原理很简单，T个线 程，每个线程占用P的CPU时间，如果刚好占满C个CPU，那么必有T×P ＝C。下面验证一下边界条件的正确性
假设C＝8，P＝1.0，线程池的任务完全是密集计算，那么T＝8。只 要8个活动线程就能让8个CPU饱和，再多也没用，因为CPU资源已经耗 光了
假设C＝8，P＝0.5，线程池的任务有一半是计算，有一半等在IO 上，那么T＝16。考虑操作系统能灵活、合理地调度sleeping/writing/running线程，那么大概16个“50％繁忙的线程”能让8个 CPU忙个不停。启动更多的线程并不能提高吞吐量，反而因为增加上下 文切换的开销而降低性能
如果P＜0.2，这个公式就不适用了，T可以取一个固定值，比如 5×C。另外，公式里的C不一定是CPU总数，可以是“分配给这项任务的 CPU数目”，比如在8核机器上分出4个核来做一项任务，那么C＝4。

### 八、除了推荐的Reactor+thread pool，还有别的non-trivial多线程编程模型吗？
有，Proactor。如果一次请求响应中要和别的进程打多次交道，那么Proactor模型往往能做到更高的并发度。当然，代价是代码变得支离破碎，难以理解。
Proactor模式依赖操作系统或库来高效地调度这些子任务，每个子任务都不会阻塞，因此能用比较少的线程达到很高的IO并发度
Proactor能提高吞吐，但不能降低延迟，所以我没有深入研究。另外，在没有语言直接支持的情况下（有的语言能通过库扩展，例如http://jscex.info/zh-cn），Proactor模式让代码非常破碎，在 C++中使用Proactor是很痛苦的。因此最好在“线程”很廉价的语言中使用 这种方式，这时runtime往往会屏蔽细节，程序用单线程阻塞IO的方式来处理TCP连接。

### 九、模式2和模式3a该如何取舍？

模式2是一个多线程的进程，模式3a是多个相同的单线程进程
我认为，在其他条件相同的情况下，可以根据工作集 的大小来取舍。工作集是指服务程序响应一次请求所访问的内存大小
如果工作集较大，那么就用多线程，避免CPU cache换入换出，影响性能；否则，就用单线程多进程，享受单线程编程的便利。举例来说：
如果程序有一个较大的本地cache，用于缓存一些基础参考数据 （in-memory look-up table），几乎每次请求都会访问cache，那么多线 程更适合一些，因为可以避免每个进程都自己保留一份cache，增加内 存使用。
memcached这个内存消耗大户用多线程服务端就比在同一台机器上 运行多个memcached instance要好。（但是如果你在16GiB内存的机器上运行32-bit memcached，那么此时多instance是必需的。）
求解Sudoku用不了多大内存。如果单线程编程更方便的话，可以用单线程多进程来做。再在前面加一个单线程的load balancer，仿 lighttpd＋fastcgi的成例。
线程不能减少工作量，即不能减少CPU时间。如果解决一个问题需要执行一亿条指令（这个数字不大，不要被吓到），那么用多线程只会让这个数字增加。但是通过合理调配这一亿条指令在多个核上的执行情 况，我们能让工期提早结束。这听上去像统筹方法，其实也确实是统筹方法。